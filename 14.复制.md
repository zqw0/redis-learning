## 复制  
**介绍**：在redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，我们称呼**被复制的服务器为主服务器**，而**对主服务器进行复制的服务器则被称为从服务器**。举例如下：  
假设现在有两个redis服务器，地址分别为127.0.0.1:6379和127.0.0.1:12345，如果我们向服务器127.0.0.1:12345发送以下命令：
```
127.0.0.1:12345> SLAVEOF 127.0.0.1 6379
OK
```
那么**服务器127.0.0.1:12345将称为127.0.0.1:6379的从服务器，理所当然127.0.0.1:6379也会成为127.0.0.1:12345的主服务器**。  
**特性**：进行复制中的主从服务器双方的数据将保存相同的数据，概念上将这种现象称作"数据库状态一致"，"或简称一致"。   
## 旧版复制功能的实现    
redis的复制功能分为**同步**和**命令传播**两个操作：  
（1）同步操作用于将从服务器的数据库状态更新至主服务器当前 所处的状态。  
（2）命令传播操作用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。  
## 同步  
当客户端向从服务器发送SLAVEOF命令，**要求从服务器复制主服务器时，从服务器首先需要执行同步操作**。同步操作需要向主服务器发送SYNC命令来完成，以下是SYNC命令执行步骤：  
（1）从服务器向主服务器发送SYNC命令。  
（2）收到SYNC命令的主服务器执行BGSAVE命令命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。  
（3）当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生存的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将字节的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。  
（4）主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。  
## 命令传播   
在执行完同步操作后，如果再有写命令作用于主服务器，比如SET K4 V1在主服务器中执行，那么就会导致主从服务器状态不一致。就需要将刚才那条在主服务器上执行的写命令，传播给从服务器。让从服务器也执行这条指令。从而达到状态一致。  
## 旧版复制功能的缺陷  
在redis2.8以前，从服务器对主服务器的复制可以分为两种情况。  
（1）初次复制：就是说还没有执行过SYNC命令，既没有同步，也没有命令传播。   
（2）断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连，重新连接上了主服务器，并继续复制主服务器。  
**问题所在**：断线后的重复制。当从服务器断开连接后，再重新连接上时。**会让主服务器重新再次执行SYNC操作，利用RDB文件进行同步**。这无疑是一个非常耗时且低效的思路。**完全可以将断线期间的命令写入一个缓冲区，在重连后，再利用缓冲区写入**。   
## 新版复制功能的实现  
redis从2.8版本开始，使用PSYNC命令代替SYNC来执行复制时的同步操作。   
**PSYNC命令具有完整重同步和部分重同步两种模式：**   
（1）完整重同步：用于处理初次复制情况，其**工作模式和原先的SYNC命令执行过程一样**。  
（2）部分重同步：用于处理断线后重复制情况，当从服务器断线重连后，如果条件允许**主服务器会将断线期间执行的写命令发送给从服务器，从服务器接收并执行这些指令。来完成同步**。举例：
```
时间                                      主服务器                                                                                                                                                                                              从服务器
T0                              主从服务器完成同步                                                                                                                                                                       主从服务器完成同步
T1                              执行并传播SET K1 V1                                                                                                                                                                    执行SET K1 V1
T2                              执行并传播SET K2 V2                                                                                                                                                                    执行SET K2 V2
...                               .......                                                                                                                                                                                                       .....
T10085                    执行并传播SET K10085 V10085                                                                                                                                                执行SET K10085 V10085
T10086                    执行并传播SET K10086 V10086                                                                                                                                                执行SET K10086 V10086
T10087                    主从服务器连接断开                                                                                                                                                                      主从服务器连接断开
T10088                    执行并传播SET K10087 V10087                                                                                                                                                断线中，尝试重连
T10089                    执行并传播SET K10088 V10088                                                                                                                                                断线中，尝试重连
T10090                    执行并传播SET K10089 V10089                                                                                                                                                断线中，尝试重连
T10091                    主从服务器重新连接                                                                                                                                                                      主从服务器重新连接 
T10092                                                                                                                                                                                                                              向主服务器发送PSYNC,如果是老版这里发送SYNC
T10093                    向从服务器返回+CONTINUE回复，表示执行部分重同步
T10094                                                                                                                                                                                                                                 接收+CONTINUE信号，准备执行部分重同步
T10095                    向从服务器发送SET K10087 V10087、SET K10088 V10088、SET K10089 V10089
T10096                                                                                                                                                                                                                                  接收并执行三个SET命令
T10097                    主从服务器再次完成同步
```
## 部分重同步的实现  
主服务器重同步功能由以下三个部分构成：    
（1）主服务器的复制偏移量和从服务器的复制偏移量。   
（2）主服务器的复制积压缓冲区。   
（2）服务器的运行ID。
## 复制偏移量  
执行复制的双方-----主服务器和从服务器会分别维护一个复制偏移量：  
（1）主服务器每次向从服务器**传播N个字节的数据时**，就将**字节的复制偏移量的值加上N**。  
（2）从服务器每次收到主服务器传播来的**N个字节的数据**时，就将自己的**复制偏移量的值加上N**。    
**此属性的意义**：帮助我们确定主从服务器之间数据是否为一致性。例子：  
比如有三个从服务器连接一台主服务器，此时的offset（复制偏移量）都为10086，当主服务器给从服务器发送33字节之前，有一台从服务器掉线了。那么除了掉线那台从服务器的复制偏移量为10086，其他几台服务器的offset属性都为10119。那么就可推断出他们的状态不一致。  
## 复制积压缓冲区  
**介绍**：复制积压缓冲区是由主服务器维护的一个固定长度先进先出队列，默认大小为1mb。  
当主服务器进行命令传播时，他不仅会将命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，因此主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。  
**话接复制偏移量**，当状态不一致时，就可以**通过复制积压缓冲区，向前找到从第几个复制偏移量断开连接的。然后只需要将这段缓冲区里面的内容重新发送给从服务器即可**。下面讨论偏移量的几种情况：  
（1）如果offset偏移量之后的数据仍然在复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。  
（2）相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区。那么主服务器将对从服务器执行完整重同步操作。   
**默认大小**：redis为复制积压缓冲区设置的默认大小为1MB。  
## 服务器运行ID  
除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID。  
**作用**：断线重连后，如何确定重连的服务器是新的从服务器，还是断线重连的服务器。  
（1）每个redis服务器，不论主服务器还是从服务器，都会有自己的运行ID。  
（2）运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成。  
当**从服务器对主服务器进行初次复制时，主服务器会将字节的运行ID传给从服务器。从服务器会保存这个运行ID。**   
当**从服务器重连上主服务器时，会将保存的运行ID传给主服务器。如果与主服务器运行ID相同，那么尝试运行部分重同步。如果不同，那么执行完整重同步**。  
## SLAVEOF复制命令的实现  
## 步骤1：设置主服务器的地址和端口  
当客户端向**从服务器**发送以下命令时：  
```
127.0.0.112345> SLAVEOF 127.0.0.1 6379
OK
```
首先要做的就是**将主服务器ip地址以及端口6379保存到服务器状态的masterhost属性和masterport属性里面**：
```
struct redisServer{
        //...
        //主服务器地址
        char *masterhost;
        
        //主服务器的端口
        int masterport;
        //...
};
```
SLAVEOF命令是一个异步命令，在完成masterhost属性和mastport属性的设置后，返回给客户端ok，表示复制指令已经被接收，实际复制工作将在ok返回之后才开始执行。  
## 步骤2：建立套接字连接  
之后从服务器将会根据主服务器的地址和端口号。创建连向主服务器的套接字连接。如果创建成功，从服务器会关联一个专门用于处理复制工作的文件事件处理器。  
主服务在接受从服务器的套接字之后，将为该套接字创建相应的客户端状态，并将从服务器看做是一个连接到主服务器的客户端来对待。此时从服务器将同时具有服务器和客户端两个身份状态。从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复。  
## 步骤3：发送PING命令  
**作用**：  
（1）虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信，通过发送PING命令可以检查套接字的读写状态是否正常。  
（2）因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以检查主服务器能否处理命令请求。  
**如果从服务器接收到回复信号PONG，那么代表正常。如果超时或者接收到错误信号。那么就重写创建套接字连接，重新连接**。  
## 步骤4：身份验证   
（1）如果主从服务器都没有设置密码，那么执行复制工作的下一个步骤。  
（2）如果不是都设置了密码，那么判断主从服务器设置的密码是否相同。相同执行复制工作的下一步。  
（3）如果设置密码不同，或者有一方设置了密码，一方没有设置密码。就返回错误，重试。  
## 步骤5：发送端口信息  
在经过身份验证后，从服务器向主服务器发送端口号。主服务器收到端口号后，将端口号记录在从服务器所对应的客户端状态的slave_listening_port属性中：  
```
typedef struct redisClient{
        //...
        //从服务器的监听端口号
        int slave_listening_port;
        //...
};
```
slave_listening_port属性目前唯一的作用就是在主服务器执行INFO replication  
## 步骤6：同步  
这一步。**从服务器将向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态**。   
**小贴士：在同步操作执行之前，只有从服务器是主服务器的客户端，但是在执行同步操作之后，主服务器也会称为从服务器的客户端**。解释如下：  
（1）如果PSYNC命令执行的是完整重同步操作，那么主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行。   
（2）如果PSYNC命令执行的是部分重同步操作，那么主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令。  
**因此，在同步操作执行之后，主从服务器双方都是对方的客户端，他们可以互相向对方发送命令请求，或者互相向对方返回命令回复。正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态。**  
## 步骤7：命令传播  
这时主服务器只要一直将字节执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令。就可以保证主从服务器一直保持一致了。  
## 心跳检测  
在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：  
```
REPLCONF ACK <replication_offset> 
```
其中replication_offset是从服务器当前的复制偏移量。  
发送REPLCONF_ACM命令对于主从服务器有三个作用：  
（1）检测主从服务器的网络连接状态。  
（2）辅助实现min-slaves选项。  
（3）检测命令丢失。  
## 检测主从服务器的网络连接状态  
主从服务器可以通过发送和接收REPLCONF ACK命令来检查两者之间的网络连接是否正常：如果主从服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现了问题。  
## 辅助min-slaves配置选项  
redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令。  
举例：如果我们向主服务器提供以下设置：  
```
min-slaves-to-write 3
min-slaves-max-lag 10
```
那么在从服务器数量少于3个，或者三个从服务器的延迟值(lag)都大于等于10秒钟时，主服务器将拒绝执行写命令。这个**lag值就是主从服务器接收回复ACK中间的时间**。  
## 检测命令丢失  
如果主服务器给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送REPLCONF ACK 命令时，**主服务器将发觉从服务器的复制偏移量少于自己的复制偏移量，然后主服务器就会根据 从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重写发送给从服务器。**  
这个原理与部分重同步基本相同。但有一些微小的区别。  
**补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步则在主从服务器断线并重连后执行。**  







