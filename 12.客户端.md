## 服务器与客户端之间关系的简单介绍  
redis服务器是典型的一对多服务器程序：**一个服务器可以与多个客户端建立网络连接**。  
对于每个与服务器连接的客户端，服务器都为这些客户端建立了相应的redisClient结构（客户端状态），这个结构包含了客户端当前的状态信息。   
而redisServer结构体中包含一个clients属性，记录了当前连接这个服务器的客户端都有哪些。
```
struct redisServer{
        //...
        //一个链表，保存了所有客户端状态
        list *clients;
        //...
};
```
## 客户端属性  
客户端状态包含的**属性可以分为两类**    
（1）一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，他们都要用到这些属性。  
（2）另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等。  
## 套接字描述符  
客户端状态fd属性记录了客户端正在使用的套接字描述符：
```
struct redisClient{
        //...
        int fd;
        //...
};
```
根据客户端类型的不同，fd属性的值**可以是-1或者是大于-1的整数**：  
（1）伪客户端的fd属性的值为-1。伪客户端处理命令请求来源于AOF文件或者lua脚本，而不是网络，所以这种客户端不需要套接字连接。**目前redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行lua脚本中包含的redis命令**。   
（2）普通客户端的fd属性值大于-1。用fd属性来记录客户端套接字的描述符。  
## 名字  
在**默认情况下，一个连接到服务器的客户端是没有名字的**。  
比如下面展示的CLIENT list命令示例中，两个客户端的name域都是空白的：  
```
redis> CLIENT list
addr=127.0.0.1:53428 fd=6 name= age=1242.....
addr=127.0.0.1:53429 fd=7 name= age=122.....
```
使用**CLIENT setname**命令可以为客户端设置一个名字，让客户端身份变得更清晰。  
以下展示的是**客户端执行**CLINET setname命令之后的客户端列表。
```
redis> CLIENT list
addr=127.0.0.1:53428 fd=6 name=message age=1242.....
addr=127.0.0.1:53429 fd=7 name=page age=122.....
```
属性存放在哪里？
```
struct redisClient{
        //..
        robj *name;//指向一个前面讲过的字符串对象。
        //..
};
```
## 标志   
客户端的标志属性flages记录了客户端的角色（role），以及客户端目前所处状态：  
```
struct redisClient{
        //...
        int flags;
        //...
};
```
flags属性可以是单个标志：  
flags=value;   
也可以是多个标志的二进制：  
flags = value | value2 | value3...;   
列出部分常量含义：  
REDIS_LUA_CLIENT：表示客户端是专门用于处理lua脚本里面包含的redis命令的伪客户端。  
REDIS_MONITOR：标志表示客户端正在执行MONITOR命令。  
详情见p165。  
## 输入缓冲区  
客户端状态的输入缓冲区**用于保存客户端发送的命令请求**：  
```
struct redisClient{
        //...
        sds     querybuf;
        //...
};
```
举例：SET key value    
就将这条指令保存进querybuf中。  
输入缓冲区的大小会根据输入内容动态的缩小或者扩大，但它的最大大小不能超过1GB，否则服务器将关闭这个客户端。  
## 命令与命令参数  
在服务器将客户端发送的命令请求**保存到客户端状态的querybuf属性之后**，服务器将**对命令请求的内容进行分析**，并将**得出的命令参数以及命令参数的个数**分别保存到客户端状态的**argv属性和argc属性**。  
```
struct redisClient{
        //...
        robj **argv;
        int argc;
        //..
};
argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数。
比如SET key value  argv[0]存入SET，argv[1]存入key，argv[2]存入value。  
```
## 命令的实现函数  
当服务器从协议内容中分析并得出argv属性和argc属性的值之后，**服务器将根据argv[0]的值，在命令表中查找该命令所对应的实现函数**。  
此**命令表是一个字典**。键是命令的字符串，如"set"。而值是对应redisCommand结构体。  
当程序在命令表中成功找到argv[0]所对应的redisCommand结构时，它会将客户端状态的cmd指针，指向这个结构：  
```
struct redisClient{
        //...
        struct redisCommand     *cmd;
        //..
};
```
## 输出缓冲区  
何时用：**执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面**，每个客户端**都有两个输出缓冲区**可用，一个缓冲区的**大小是固定的**，另一个缓冲区的**大小是可变的**。  
**（1）固定大小缓冲区**  
客户端 的固定大小缓冲区由buf和bufpos两个属性组成：  
```
struct redisClient{
        //...
        char buf[REDIS_REPLY_CHUNK_BYTES];
        int bufpos;
};
```
其中buf为存命令的数组。bufpos为已用的空间。  
REDIS_REPLY_CHUNK_BYTES的默认大小为16 × 1024。也就是16kb。  
**当回复的大小大于16KB时，就使用可变大小缓冲区**。  
**（2）可变大小缓冲区**  
可变大小缓冲区由reply链表和一个或多个字符串对象组成：
```
struct redisClient{
        //...
        list *reply;
        //...
};
```
## 身份验证  














