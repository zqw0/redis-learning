## 集群与本章任务的介绍
redis集群是redis提供分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。  
本节将对集群的节点、槽指派、命令执行、重写分片、转向、故障转移、消息等各个方面进行介绍。  
## 节点  
**节点示意**：当前我在看本章的理解，就是一个ip地址开放的一个端口号。比如127.0.0.1:7000这算一个节点。  
一个redis集群通常是由多个节点组成。但在刚开始的时候，每个节点都是独立的。他们都处于一个只包含字节的集群当中。所以我们**需要将各个节点连接起来，组成一个真正的集群**。   
连接各个节点node的工作可以发送ClUSTER MEET命令来完成，该命令的格式如下：  
```
CLUSTER MEET <IP> <PORT>
```
此命令可以让node节点与ip和port所指定的节点进行握手，当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中。  
## 启动节点  
一个节点就是一个运行在集群模式下的redis服务器，redis服务器在启动会**根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式**。  
节点（运行在集群模式下的redis服务器）会继续使用所有在单机模式中使用的服务器组件，比如说：  
（1）节点会继续使用文件事件处理器来处理命令请求和返回命令回复。  
（2）节点会继续使用时间事件处理器来执行serverCron函数，而serverCron函数又会调用集群模式特有的clusterCron函数。clusterCron函数负责执行在集群模式下需要执行的常规操作，例如向集群中其他节点发送Gossip消息，检查节点是否断线，或者检查是否需要对下线节点进行自动故障转移等。  
（3）节点会继续使用数据库来保存键值对数据，键值对依然会是各种不同类型的对象。  
（4）节点会继续使用RDB持久化模块和AOF持久化模块来执行持久化工作。   
（5）节点会继续使用发布与订阅模块来执行PUBLISH、SUBSCRIBE等命令。  
（6）节点会继续使用复制模块来进行节点的复制工作。  
（7）节点会继续使用Lua脚本环境来执行客户端输入的Lua脚本。  
（8）节点会继续使用redisServer结构来保存服务器状态，使用redisClient结构来保存客户端状态，至于那些只有在集群模式下才会用到的数据，节点将他们保存到clusterNode结构、clusterLink结构以及clusterState结构中。  
## 集群数据结构  
clusterNode结构：保存了一个节点的当前状态：比如节点的创建时间，节点的名字，节点当前的配置纪元，节点的IP和PORT等。  且每一个节点都有这样一个结构，来保存自己的状态。  
```
struct clusterNode{
        //创建节点的时间
        mstime_t ctime;
        
        //节点的名字，由40个十六进制的字符组成
        char name[REDIS_CLUSTER_NAMELEN];
        
        //节点标识
        //使用各种不同的标识值记录节点的角色（比如主节点或者从节点）
        //以及节点目前所处的状态（比如在线或者下线）。
        int flags;
        
        //节点当前的配置纪元，用于实现故障转移
        uint64_t configEpoch;
        
        //节点的IP地址
        char ip[REDIS_IP_STR_LEN];
        
        //节点的端口号
        int port;
        
        //保存连接节点所需的有关信息
        clusterLink *link;
        //...
};
```
clusterLink结构的link属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区：
```
struct clusterLink{
        //连接的创建时间
        mstime_t ctime;
        
        //TCP套接字描述符
        int fd;
        
        //输出缓冲区，保存着等待发送给其他节点的消息。
        sds sndbuf;
        
        //输入缓冲区，保存着从其他节点接收到的消息。
        sds rcvbuf;
        
        //与这个连接相关联的节点，如果没有的话就为null。
        struct clusterNode *node;
};
```
最后每个节点都保存这一个clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元等。
```
struct clusterState{
        //指向 当前节点的指针
        clusterNode *myself;
        
        //集群当前的配置纪元，用于实现故障转移
        uint64_t currentEpoch;
        
        //集群当前的状态，是在线还是下线
        int state;
        
        //集群中至少处理着一个槽的节点的数量
        int size;
        
        //集群节点名单包括自己。
        //字典的键为节点的名字，字典的值为节点对应的clusterNode结构。
        dict *nodes;
        
        //...
};
```
## CLUSTER MEET命令的实现  
客户端可以让接收命令的节点A将另一个节点B添加到节点A当前所在的集群里面。  
```
CLUSTER MEET <ip> <port>
```
收到命令的节点A将与节点B进行握手，以此来确认彼此的存在，并未将来的进一步通信打好基础：  
（1）节点A会为B创建一个clusterNode结构，并将该结构添加到字节的clusterState.nodes字典里面。  
（2）之后，节点A将根据CLUSTER MEET命令给的IP和端口号，向节点B发送一条MEET消息。  
（3）如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到字节的clusterState.nodes字典里面。  
（4）之后，节点B将向节点A返回一条PONG消息。  
（5）如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功的接收到了字节发送的MEET消息。  
（6）之后，节点A将向节点B返回一条PING消息。  
（7）如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功的接收到了字节返回的PONG消息，握手完成。  
之后节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，最终，经过一段时间之后，节点B会被集群中的所有节点认识。  
## 槽指派  
**解释槽和槽的用处**：redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot）,数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。  
当数据库中的**16384个槽都有节点在处理时**，集群处于**上线**状态（ok），相反，如果数据库中**有任何一个槽没有得到处理**，那么集群处于**下线**状态。  
通过向节点发送CLUSTER ADDSLOTS命令，我们可以将一个或多个槽指派给节点负责：
```
CLUSTER ADDSLOTS <slot> [slot ...]
```
举例：执行以下命令可以将槽0至槽5000指派给节点7000负责：  
```
127.0.0.1:7000> CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000
OK
```
这样集群还没有上线，我们需要将所有槽全部分配完毕。如何查看集群是否上线呢？
```
CLUSTER INFO
```
## 记录节点的槽指派信息  
clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽：
```
struct clusterNode{
        //...
        unsigned char slots[16384/8];
        int numslots;//负责记录处理槽的数量
        //...
};
```
slots属性是一个二进制数组，这个数组的长度为16384/8=2048个字节，共包含16384个二进制位。  
redis以0为起始索引，16383为终止索引。对16384个二进制位进行编号。如果**索引i上的二进制为1，那么表示节点负责处理槽i**，如果**索引i上的二进制为0，那么表示节点不负责处理槽i**。   
## 传播节点的槽指派信息  
一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots属性之外。它还会发消息给集群中的其他节点，告诉他们自己目前负责处理哪些槽。  
而其他节点接收到此消息后，会将字节的clusterState.nodes字典中查找发消息的那个节点对应的clusterNode结构，并对结构中的slots数组进行保存或者更新。  
## 记录集群所有槽的指派信息  
clusterState结构中的slots数组记录了集群中的所有16384个槽的指派信息：  
```
struct clusterState{
        //....
        clusterNode *slots[16384];
        //...
};
```
slots数组包含16384个项，**每个数组项，都是一个指向clusterNode结构的指针**：  
（1）如果slots[i]指针指向NULL，那么表示槽i尚未指派给任何节点。  
（2）如果slots[i]指针指向一个clusterNode结构，那么表示槽i已经指派给了clusterNode结构所代表的节点。  
## CLUSTER ADDSLOTS命令的实现  
CLUSTER ADDSLOTS命令接收一个或 多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责。
该命令实现的大致逻辑：  
（1）检查用户输入的槽是否合法（是否已经被指派）。如果其中有一个槽已经被指派，那么就返回错误。  
（2）如果都没有被指派，那么就改变clusterState.slots和clusterNode.slots属性。并返回成功。  
## 在集群中执行命令  
将全部的槽进行指派后，集群就会进入上线状态。这时客户端就可以向**集群中的节点**发送数据命令了。  
接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：    
（1）如果键所在槽正好就指派给了当前节点，那么节点直接执行这个命令。    
（2）如果键所在槽并没有指派给当前节点，那么节点会向客户端**返回一个MOVED错误，指引客户端转向至正确的节点，并再次发送之前想要执行的命令**。（此过程全部由客户端负责，不需要用户再重新发送。且MOVED错误不会呈现给用户，客户端会直接处理掉）。举例：  
```
127.0.0.1:7000> SET msg "happy new year!"
->Redirected to slot [6257] located at 127.0.0.1:7001       #因为6257槽不归7000端口这个节点管，所以会先跳到7001这个节点上。
OK

127.0.0.1:7001> GET msg                                                               #已经跳到7001节点位置上
"happy new year!"
```
## 判断槽是否由当前节点负责处理  
当前节点计算出键所属的槽i后，节点直接检查clusterState.slots[i]是否等于clusterState.myself即可。如果相等，说明这个槽i就被自身节点所管理。如果不相等，那么说明这个槽i就被其他几点所管理。之后只需要跳到那个节点即可。  
## MOVED错误  
**描述**：当节点发现键所在的槽并非由字节负责处理的时候，节点就会向客户端返回一个MOVED错误，指引客户端转向至正在负责槽的节点。  
MOVED错误格式为：
```
MOVED <slot> <ip>:<port>
```
其中slot为键所在的槽，ip和port则是负责处理槽的节点的ip和port。
所以当客户端接收到节点返回的MOVED错误时，客户端会根据MOVED提供的信息，转至负责处理槽的节点，并向该节点重新发送之前想要执行的命令。  
**一个集群客户端通常会与集群中的多个节点创建套接字连接，而所谓的节点转向实际上就是换一个套接字来发送命令**。  
## 节点数据库的实现  
节点和单机服务器在数据库的一个**区别**是：节点只能使用0号数据库，而单机redis服务器则没有这一限制。  
另外，除了将键值对保存在数据库里面之外，节点还会**用clusterState结构中的slots_to_key跳跃表来保存槽和键之间的关系**：
```
struct clusterState{
         //...
         zskiplist *slots_to_keys;
         //...
};

```
slots_to_key跳跃表每个**节点的分值都是一个槽号**，而每个**节点的成员是一个数据库键**。至于实现，跳跃表已经讲的非常情况，不再叙述。
## 重新分片  



