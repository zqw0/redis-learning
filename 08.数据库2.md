## 设置键的生存时间或过期时间   
通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To  Live, TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间0的键：
```
redis>  SET key value
OK

redis> EXPIRE key 5
(integer) 1

redis>  GET key //5秒之内
"value"

redis>  GET key //5秒之后
(nil)
```
**如何查看一个键的剩余生存时间**？  
使用TTL，PTTL命令。
```
redis> SET key value
OK

redis> EXPIRE key 1000
(integer) 1

redis> TTL key
(integer) 997

redis> PTTL key
(integer) 93633
```
## 设置过期时间  
redis有四个不同的命令可以用于设置键的生存时间。
（1）EXPIRE用于将键key的生存时间设置为ttl秒。  
（2）PEXPIRE用于将键key的生存时间设置为ttl毫秒。  
（3）EXPIREAT用于将键key的过期时间设置为timestamp所指定的秒数时间戳。  
（4）PEXPIREAT用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。   
但是这四个命令最终都会转换到PEXPIREAT上来执行。  
### 保存过期时间  
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称之歌字典为过期字典：  
（1）过期字典是的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。  
（2）过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间--------一个毫秒精度的unix时间戳。  
```
typedef struct redisDb{
        //...
        //过期字典，保存着键的过期时间
        dict  *expires;
        
}redisDb;
就是将字典中的键指向设置过期时间的对象，字典中的值存放过期时间的时间戳。
```
### 移除过期时间  
使用PERSIST命令可以移除一个键的过期时间：
```
redis> PERSIST msg
```
## 过期键删除策略  
有如下**三种策略**：  
（1）定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操行。  
（2）惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键。如果没有过期，就返回该键。  
（3）定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及检查多少个数据库，则有算法决定。  
定时删除评估：对内存友好，但是对cpu不友好。  
惰性删除评估：对cpu友好，但是对内存不友好。
定期删除评估：是一种折中，但是需要看策略的好快。  
## redis的过期键删除策略  
策略：将惰性删除与定期删除相结合。  
**惰性删除的实现**  
只要在查询或者修改前，判断此键是否在过期字典中即可。不再赘述。   
**定期删除策略的实现**  
它在规定时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。  
**大致实现策略**  
（1）设置一次检查要检查多个数据库，设置检查一个数据库要检查多少个键，设置一个全局变量记录检查了多少个数据库。  
（2）在规定时间内，依次检查数据库。每次检查数据库从过期字典中，随机删除键值。时间到了之后，将这个全局变量设置为该检查数据库的序号。  
（3）在下次删除的时候，接着从上次的数据库，继续删除。  
## AOF、RDB和复制功能对过期键的处理  
## 生成RDB文件  
在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。  
## 载入RDB文件  
在启动redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：    
（1）如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期的键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。    
（2）如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中，不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。  
## AOF文件写入  
当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。  
**当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显示的记录该键已被删除**。  
举个例子，如果客户端使用GET message命令，试图访问过期的message键，那么服务器将执行以下三个动作：  
（1）：从数据库中删除message键  
（2）：追加一条DEL message命令到AOF文件。  
（3）：向执行GET命令的客户端返回空回复。  
## AOF重写  
已过期的键不会被保存到重写后的AOF文件中。  
## 复制  
当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制，来保持数据的一致性。  
（1）主服务器在删除一个过期键 之后，会显示 的向所有服务器发送一个DEL命令，告知从服务器删除这个过期键。  
（2）从服务器在执行客户端发送的读命令时，即使碰到了过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。  
（3）从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。   
## 数据库通知  
这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。    
举个例子，以下代码展示了客户端如何获取0号数据库中针对message键执行的所有命令：  
```
127.0.0.16379>  SUBSCRIBE _ _keyspace@0_ _:message
Reading messages... (press Ctrl-C to quit)
关注此订阅键后，对此键的操作，你就可以看到别人都对此键做了什么操作。
```
这一类关注"某个键执行了什么命令"的通知称为**键空间通知**，除此之外，还有一类称为**键事件通知**，他关注的是某个命令被什么样的键执行了。
```
127.0.0.16379>  SUBSCRIBE _ _keyspace@0_ _:del                                             //关注del命令被什么键执行了。
Reading messages... (press Ctrl-C to quit)
关注此订阅键后，对此键的操作，你就可以看到别人都对此键做了什么操作。
```
## 发送通知  
发送数据库通知的功能是由下面函数实现的：
```
void notifyKeyspaceEvent(int type, char *event, robj *key,int dbid);
```
函数的type参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知。  
event、keys、dbid分别是事件的名称、产生事件的键、已经产生事件的数据库号码，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。

