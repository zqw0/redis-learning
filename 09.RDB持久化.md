## 介绍  
因为redis数据库是内存数据库。所以一旦redis进程退出，数据也会丢失。为了解决这个问题，redis提供了RDB持久化功能，这个功能可以将redis在内存中的数据库状态保存到磁盘里，避免数据意外丢失。  
RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。   
## RDB文件的创建与载入  
有两个redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。  
**1.SAVA命令会阻塞Redis服务进程，知道RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求**。  
**2.BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求**。   
RDB文件的载入是在服务器启动时，自动执行的。所以并没有专门用于载入rdb文件的命令。  
另外一提的是，因为AOF文件更新频率通常比RDB文件更新频率高，所以：  
（1）如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。    
（2）只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。  
## 自动间隔性保存  
因为BGSAVE是不阻塞的，它的保存功能由子进程来执行。所以我们可以让服务器每隔一段时间自动执行一次BGSAVE命令。  
用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。举个例子：
```
save 900 1
save 300 10
save 60 10000
```
那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行。  
（1）服务器在900秒内，对数据库进行了至少一次修改。  
（2）服务器在300秒内，对数据库进行了至少10次修改。  
（3）服务器在60秒内，对数据库进行了至少10000次修改。  
## 设置保存条件  
当用户没有主动设置save选项，那么服务器会为save选项设置默认条件：
```
save 900 1
save 300 10
save 60 10000
```
接着，服务器会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：
```
struct redisServer{
        //...
        //记录了保存条件的数组
        struct saveparam *saveparams;
        //...
};
```
saveparams属性是一个数组，数组中每个元素都是一个saveparam结构，saveparam结构保存了一个save选项设置的保存条件。
```
struct saveparam{
        //秒数
        time_t seconds;
        //修改数
        int changes;
};
```
## dirty计数器和lastsave属性  
**1.dirty计数器记录距离上次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态进行了多少次修改**。  
**2.lastsave属性是一个unix时间戳，记录了服务器上次成功执行save命令或者BGSAVE命令的时间**。
```
struct redisServer{
        //....
        //修改计数器
        long long dirty;
        //上一次执行保存的时间
        time_t lastsave;
        //...
};
```
## RDB文件结构  
包含这样5个结构REDIS、db_version、databases、EOF、check_sum  。  
1：RDB文件最开头是REDIS部分，这个部分的长度为5字节，保存着"REDIS"五个字符。通过这5个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。  
2：db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB的版本号。   
3：databases部分包含着0个或任意多个数据库，以及各个数据库中的键值对数据。  
（1）：如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。  
（2）：如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库的大小，这部分长度也会有所不同。  
4：EOF常量的长度为1字节，这个常量标志着RDB文件正文内容结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕。  
5：check_sum是一个8字节的无符号整数，保存着一个校验和。  
## databases部分  
每个databases又有以下三部分组成。SELECTDB、db_number、key_value_pairs三部分。    
（1）SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。    
（2）db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节，2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号进行数据库切换，使得之后读入的键值可以载入到正确的数据库中。    
（3）key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件不同，这部分长度也会有所不同。  
## key_value_pairs部分  
**不带过期时间**的键值对由TYPE、KEY、VALUE三部分组成。
（1）type记录了value的类型。长度为1字节。   
（2）key总是一个字符串对象。前面介绍过，不再详细叙述。  
（3）根据type类型的不同，以及保存内容长度的不同，保存value结构和长度也会有所不同。稍后解释。  
**带有过期时间**的键值对又以下5部分组成，EXPIRETIME_MS、ms、TYPE、key、value。  
（1）EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。  
（2）ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对过期时间。  
